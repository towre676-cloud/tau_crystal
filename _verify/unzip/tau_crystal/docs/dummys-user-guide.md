---
title: Dummy’s User Guide
layout: page
permalink: /guide
---

Imagine you have never heard of Lean, cosign, or Merkle trees. You only know that someone mailed you a zip file called tau_crystal-main.zip and said “everything you need is inside.” You unzip it, double-click the folder, and see a lot of tiny shell scripts and one stubborn file called PANIC that you are told never to create unless the house is on fire. That is the first lesson: the repository is polite until you panic it; then it slams every door.

Open the terminal that came with your machine. If you are on Windows, use Git Bash; on macOS or Linux, any terminal will do. Change directory into the folder you just unzipped so your prompt shows you are inside the project tree. Run the strict assurance script and press return. The screen goes quiet for a moment, then prints one line stating the current commit hint, the freshly computed Merkle root, the UTC timestamp, and the path to the receipt it just wrote under the ledger. That single sentence means the repository has fingerprinted every tracked source file, folded the hashes into a canonical tree, chained the new root to the previous one, and persisted the evidence. You did not install Lean, Rust, or Python to get here; the script only needs a shell, Git to list tracked files, and a SHA-256 tool, and it has fallbacks if one is missing. Failure modes are loud: no tracked files, missing paths, or a read-only ledger produce a single, human sentence and a non-zero exit.

Now run the offline verifier. It reopens the receipt, re-hashes its JSON bytes to confirm the ledger line is truthful, re-derives the Merkle root from the file list recorded in that receipt, and compares them. If even one byte in the working tree has changed since the receipt was minted, the verification fails. You do not need to know what a Merkle root is; treat the verifier like a calibrated scale that beeps only when the package is exact.

If you want the house to speak mathematics, install the Lean toolchain manager and build the tiny executable that checks the link between the last two ledger lines and the receipt itself. When it reports chain OK, Lean has parsed the ledger, read the receipt, and confirmed that the prev field equals the digest on the previous line. If someone hand-edits either hash, the executable returns a specific mismatch and a non-zero exit. Think of it as a digital caliper: it does one measurement and refuses to round up.

For the most hostile settings, fetch the sealed verifier binary that needs nothing but a shell. Download the statically linked tau_verify, mark it executable, and run it against the repository directory. It prints OK when the same invariant holds: the working tree’s canonical file set, folded into a Merkle root, matches the root recorded in the most recent receipt, and the receipt’s own bytes hash to the value recorded in the ledger. If you want extra ceremony, you may also fetch the accompanying signature and certificate and have cosign verify the blob before you run it, but that is optional because the tool’s job is to recompute, not to trust. You now have three independent views of one fact—Bash, Lean, and a sealed Rust hand-lens—and all three must agree for the gate to stay open.

Use the repository for real work. Create a small file, stage it with Git, mint a receipt again, and watch the ledger advance. Remove the file and mint another receipt and the hash swings back. The system is live: it tracks the exact bytes you are working on, not a romantic snapshot from last month.

To ship your work to a sceptical colleague who does not trust any of your infrastructure, mint a witness pack. The publisher writes a compact tarball under the ledger’s discovery area with a timestamped name. When someone untars that pack anywhere and runs the sealed verifier on it, they are holding a self-describing bundle: it includes the receipt that was current when you minted the pack, the environment attestation from the runner that produced it if one was present, and a manifest that lists the contents. The bundle also has a single line in a small chain that binds the tarball’s own digest to the same ledger you use inside the gate. The recipient can ignore your mathematics entirely and rely on a simple proposition: if the verifier exits zero on the pack, the bytes they are holding are exactly the bytes that produced the recorded receipt.

You can still explore ambitious mathematics and dense experiments. Place those workflows in the labs area and run them to your heart’s content. They can upload heavy outputs and paint pretty pictures; none of that can influence the merge gate because the policy forbids labs from gating. If you accidentally place an aspirational workflow at the root, a local pre-push hook blocks the push and the spec-guard fails in continuous integration. Ornament is encouraged, but it never bears weight.

If you need to pull the emergency brake, create an empty file named PANIC in the repository root and commit it. Every workflow fails quickly, the pre-push hook rejects pushes, and the sentinel job goes red. Remove the file and the gate re-opens. That switch is the only mutable boolean in the entire system; everything else is append-only and hash-linked.

That is the whole loop. You arrive with a zip file and leave with a small static binary that can tell any stranger, in a second and without discussion, whether the repository they are holding is bit-for-bit identical to the one you certified. The mathematics can be rough and the experiments whimsical, but the claim of reproducibility is now machine-checkable, offline, and independent of trust in your tools. The repository no longer argues; it weighs.
