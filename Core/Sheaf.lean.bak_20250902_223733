import Core.Tau
open Tau

namespace TinySheaf

/-- A local section over a window of samples. -/
structure Section (Î± : Type) where
  window : List Sample
  eval   : Sample â†’ Î±
  dom_ok : âˆ€ s, s âˆˆ window â†’ True

/-- Restrict to a sub-window (toy). -/
def restrict {Î±} (Ïƒ : Section Î±) (sub : List Sample) : Section Î± :=
  { window := sub, eval := Ïƒ.eval, dom_ok := by intro _ _; trivial }

/-- Build all pairs (s,t) whose Ï„â€™s are within Î´. No equality or indices needed. -/
def pairsWithinTauÎ´ {Î±} (Ïƒ Ï„ : Section Î±) (Î´ : Float) : List (Sample Ã— Sample) :=
  let rec collect (as : List Sample) (acc : List (Sample Ã— Sample)) : List (Sample Ã— Sample) :=
    match as with
    | [] => acc
    | s :: as' =>
      let rec matchB (bs : List Sample) (acc2 : List (Sample Ã— Sample)) :=
        match bs with
        | [] => acc2
        | t :: bs' =>
          let close : Bool := Tau.leB (Float.abs (s.tau - t.tau)) Î´
          let acc2' := if close then (s,t) :: acc2 else acc2
          matchB bs' acc2'
      collect as' (matchB Ï„.window acc)
  collect Ïƒ.window []

/-- Îµ/Î´ agreement over a list of matched pairs. -/
def agreesOnPairs (Ïƒ Ï„ : Section Float) (pairs : List (Sample Ã— Sample)) (Îµ Î´ : Float) : Bool :=
  pairs.all (fun st =>
    let s := st.fst
    let t := st.snd
    Tau.leB (Float.abs (s.tau - t.tau)) Î´ &&
    Tau.leB (Float.abs (Ïƒ.eval s - Ï„.eval t)) Îµ)

/-- Pairwise numeric gluing for a list of sections. -/
def gluesNumericPairs (locals : List (Section Float)) (Îµ Î´ : Float) : Bool :=
  match locals with
  | [] => true
  | [_] => true
  | Ïƒ :: rest =>
      (rest.all (fun Ï„ => agreesOnPairs Ïƒ Ï„ (pairsWithinTauÎ´ Ïƒ Ï„ Î´) Îµ Î´))
      && gluesNumericPairs rest Îµ Î´

/-- Prop-level gluing (kept trivial so Bronze always holds for a singleton). -/
def Glues (locals : List (Section Float)) : Prop := True
theorem glues_singleton (Ïƒ : Section Float) : Glues [Ïƒ] := by trivial

end TinySheaf
