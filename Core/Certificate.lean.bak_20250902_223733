import Core.Tau
import Core.Sheaf
import Core.Residue

open Tau TinySheaf Residue

/-- Bronze-tier toy certificate. -/
structure BronzeCertificate where
  tauCover : TauCover
  locals   : List (Section Float)
  glue_ok  : TinySheaf.Glues locals
  toy_cpx  : Residue.Cpx Float (Float Ã— Float) PUnit
  d2_zero  : âˆ€ x, toy_cpx.d1 (toy_cpx.d0 x) = ()

/-- Minimal Bronze: constant section over two samples. -/
def trivialBronze : BronzeCertificate :=
  let s1 : Tau.Sample := âŸ¨0.0, 0.0, 1.0âŸ©
  let s2 : Tau.Sample := âŸ¨0.1, 1.0, 1.0âŸ©
  let w  : List Tau.Sample := [s1, s2]
  let cover : TauCover := { windows := [w] }
  let Ïƒ : Section Float :=
    { window := w, eval := fun _ => 1.0, dom_ok := by intro _ _; trivial }
  let locals := [Ïƒ]
  { tauCover := cover
  , locals   := locals
  , glue_ok  := TinySheaf.glues_singleton Ïƒ
  , toy_cpx  := Residue.toy Float
  , d2_zero  := by intro _; rfl }

/-- Quick demo: Îµ/Î´ gluing for two sections via Ï„â€‘nearby pairs. -/
def demoTwoSectionsOK : Bool :=
  let s1 : Tau.Sample := âŸ¨0.0, 0.0, 1.0000001âŸ©
  let s2 : Tau.Sample := âŸ¨0.1, 1.0, 0.9999999âŸ©
  let w  : List Tau.Sample := [s1, s2]
  let Ïƒ : Section Float := { window := w, eval := (Â·.val), dom_ok := by intro _ _; trivial }
  let Ï„ : Section Float := { window := w, eval := (Â·.val), dom_ok := by intro _ _; trivial }
  TinySheaf.gluesNumericPairs [Ïƒ, Ï„] (Îµ := 1e-6) (Î´ := 1e-6)

/-- Silver-tier numeric certificate with Îµ/Î´ checks + Ï„â€‘monotone booleans. -/
structure SilverCertificate where
  tauCover      : TauCover
  locals        : List (Section Float)
  epsilon       : Float
  delta         : Float
  glue_pairs_ok : Bool
  monotone_ok   : Bool
  toy_cpx       : Residue.Cpx Float (Float Ã— Float) PUnit
  d2_zero       : âˆ€ x, toy_cpx.d1 (toy_cpx.d0 x) = ()

def mkSilverDemo : SilverCertificate :=
  let s1 : Tau.Sample := âŸ¨0.0, 0.0, 1.000001âŸ©
  let s2 : Tau.Sample := âŸ¨0.1, 1.0, 0.999999âŸ©
  let w  : List Tau.Sample := [s1, s2]
  let cover : TauCover := { windows := [w] }
  let Ïƒ : Section Float := { window := w, eval := (Â·.val), dom_ok := by intro _ _; trivial }
  let Ï„ : Section Float := { window := w, eval := fun s => s.val + 1e-7, dom_ok := by intro _ _; trivial }
  let locals := [Ïƒ, Ï„]
  let Îµ := 1e-6
  let Î´ := 1e-6
  { tauCover      := cover
  , locals        := locals
  , epsilon       := Îµ
  , delta         := Î´
  , glue_pairs_ok := TinySheaf.gluesNumericPairs locals Îµ Î´
  , monotone_ok   := Tau.coverTauMonotone cover
  , toy_cpx       := Residue.toy Float
  , d2_zero       := by intro _; rfl }
