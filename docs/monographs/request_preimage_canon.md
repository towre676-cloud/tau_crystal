# Request Preimage Canon and Digest

There is no ledger without bytes, and there is no trust without conservation. The request preimage canon exists to guarantee that every structured interaction with the τ-Crystal adapter begins from an invariant: a byte string that is preserved exactly as received and a digest that is computable by any observer without coordination or interpretation. This document defines the canonical entrance of requests into the system, proves that the entrance is faithful to the bytes, and explains why that fidelity is the smallest unit of epistemic stability in our verification stack.

The contract is simple. A caller presents a request as either a file path or a stream on standard input. The preimage writer persists those bytes to `analysis/<stem>.request.canon.json` without modification, without normalization, and without newline or encoding games that could alter meaning in transit. Immediately after the write, the writer computes a SHA-256 digest over the exact bytes it just stored and emits the hexadecimal digest on standard output. The digest is not a claim about meaning; it is an address for the bytes themselves, a content key that external tools, auditors, and future builds can recompute without trusting our code. In practice this means a single shell pipeline can both capture the preimage and checkpoint the digest into `.tau_ledger/<stem>.sha256`, and every later stage can refer to that handle without ambiguity.

Two properties turn this into more than a convenience. The first is determinism of ingress. Because the script refuses empty stdin, refuses missing files, and never transforms line endings or encodings, the preimage it writes is a fixed point of the path from caller to disk: a second invocation on the same input results in the same digest and the same bytes, full stop. The second is symmetry with external computation. Because the digest is generated with standard tools (`sha256sum`, `shasum`, or `openssl`) and because we never postprocess those tools’ outputs, an observer using their own environment will compute the same digest when pointed at the stored preimage. These two facts are enough to anchor the rest of the ledger: if an analysis, a receipt, or a model output claims to derive from a given request, it must cite the preimage digest, and that citation can be verified by recomputing the hash on the canonical file stored under `analysis/`.

This minimal mechanism bites deeper into the adapter layer than it first appears. The adapter’s job is to translate between the world of prompts, contracts, and behavioral gates, and the world of receipts, manifests, and formal proofs. Without a preimage canon, the adapter would risk drifting into a negotiation about what the “real” input was whenever a gate fails or a receipt does not replay. With the canon, the adapter never needs to defend an interpretation; it points to a file whose digest is its identity and to a ledger line that records that identity. The adapter can then frame all subsequent checks—syntactic validation against JSON schema, semantic conformance to allowed capability sets, and behavioral alignment with τ-crystal toggles—as functions from a stable input value to a reproducible output. When a discrepancy appears, there is no appeal to formatting tools, editors, terminals, or invisible newline conversions; the bytes win.

The same austerity secures replay and attestation. A receipt that names a digest but cannot reconstruct its preimage is incomplete; a manifest that lists a sequence of operations but does not include the digest of the initiating request is unverifiable. By making the preimage canon the first artifact of every run, and by storing it under a name that couples human intent (`<stem>`) to machine identity (the digest), we equip both humans and machines to follow the same trail. Humans can open the file and read the request. Machines can recompute the digest and compare it to the ledger. If either disagrees with a later claim—say, that a certain gate decision was made on a different prompt—the disagreement is falsified by a single hash.

There is also a pragmatic performance and ergonomics angle. The preimage canon eliminates accidental cache busting within CI and in local development, because the digest acts as a stable key. When we memoize an expensive semantic parse or a gate result, we key that memo by the preimage digest. If a developer edits whitespace in a request, the digest changes and the memo invalidates. If the request is truly identical, the memo hits. This cheap, exact boundary saves us from the subtle class of nondeterminism that arrives through text editors, code formatters, or shell pasting. The stricter the boundary, the less ceremony we need inside it.

Finally, the preimage canon is deliberately small because it must be composable. It composes with transparency logs by allowing us to anchor the digest periodically without reformatting the request. It composes with receipts by giving each receipt a stable origin field that does not depend on environment or toolchain. It composes with formal verification by allowing Lean-side statements to phrase theorems that quantify over the digest and not over ambient strings. When we eventually extend the ledger with cross-repository discovery couplings or with q-deformed arithmetic streams, the same digest will serve as the canonical input reference without negotiation or migration.

The law of the entrance is therefore spare: preserve bytes exactly; compute a standard hash; speak only the digest. Everything else in τ-Crystal—gates, receipts, manifests, proofs—becomes easier to reason about because the system admits an unambiguous starting point. The script that implements this contract is small on purpose. Its very smallness is a feature: there is less to misunderstand, less to port, and less to trust. The artifact it leaves behind is large in consequence, because it pins all later claims to a stable address in byte space. That address is the difference between persuasion and verification.
