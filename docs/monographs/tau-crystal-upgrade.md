τ-Crystal Infrastructure Upgrade — Cryptographic Documentation Attestation System

This upgrade converts documentation from narrative description into a computational artifact with verifiable provenance. The text itself now moves through the same deterministic pipeline as code: inputs are normalized, outputs are canonical, and every state carries an immutable fingerprint that binds it to time and to history. Trust is not inferred; it is computed.

The multi-signature subsystem keeps proof material separate from structural metadata. The manifest does not embed raw signature bytes. It points to public keys and detached signature files with relative, POSIX-normalized paths, so the same repository, checked out on different machines, remains comparable without translation. Verification constructs a stable message from the current Merkle root and its timestamp and attempts validation for each referenced signer. It reports both the number of attempted validations and the number that succeed, so the difference between an absent signature and an invalid signature is explicit and diagnostically useful rather than hidden behind a single failure code. Threshold policy is enforced by the continuous integration gate, not the schema, which keeps the format stable and pushes policy to configuration.

The compression architecture emits a tarball and a zip archive, each recorded in the manifest with a clear algorithm label and a SHA-256 digest. This dual output provides redundancy across platforms while remaining deterministic. Paths stored inside the archives are normalized to forward slashes, inputs are fed in lexicographic order, GNU tar format fixes structural layout, and ZIP_DEFLATED stabilizes compression behavior. A tarball or zip created on Windows is byte-identical to one created on Linux when the inputs are the same. Packaging becomes a declared transformation whose products are publicly auditable rather than opaque containers that smuggle variance into the build.

External anchoring extends verification beyond repository control to an external, time-oriented witness. When the OpenTimestamps client is available, the stamper produces a timestamp for the manifest and writes the resulting .ots file alongside it. That file is an independent proof of existence at a specific instant in UTC and can be validated even if the repository is unavailable or its history is rewritten. If the anchoring tool is absent, stamping proceeds without anchors and the omission is explicit rather than silent. Anchors appear in the manifest as first-class artifacts, referenced by relative path and digest so they are checked with the same discipline as any other declared file.

Metadata is included deliberately and only when present. Author, description, tags, and source are accepted from environment variables, trimmed of incidental whitespace, normalized, and written into the manifest in a way that does not disturb canonical output when they are absent. Tag parsing is robust to stray spaces, which avoids accidental variants. Metadata therefore carries human intent without introducing entropy into the build surface.

The verification script now proves more than file integrity. It recomputes the Merkle root from declared file hashes and compares it to the manifest’s value. It enforces archive algorithm labels and digests. It validates multi-signature thresholds by counting attempts and successes against the configured requirement. It verifies the presence and hash of anchoring artifacts. It optionally evaluates proof-of-work by checking leading zero bits of a hash constructed from the Merkle root, the UTC timestamp, and a nonce. Each check yields precise diagnostics tied to a single invariant rather than a generic failure. Backward compatibility is maintained so earlier manifests remain valid under the expanded rules.

Continuity across time is asserted cryptographically. Each new manifest records the previous commit’s Merkle root and verification ensures the link matches history. This creates a chain of documentation states in which no transition is implicit and no gap can pass unnoticed. The temporal structure of the record is thus as verifiable as its content, and the repository carries an auditable storyline made of hashes rather than assumptions.

Signatures are detached and verify a stable message defined by the current build surface. The message is the Merkle root followed by a newline and then the UTC timestamp, exactly as:

merkle_root + "\n" + timestamp_utc

This form is unambiguous and resists whitespace drift. It also binds content to time so replayed signatures against different manifests do not verify. Policies around how many signers must attest, which algorithms are accepted, and whether a signer set is fixed or rotating are expressed in CI rather than in the on-disk format, which preserves determinism in the data structure while allowing operational evolution.

Every pathway for incidental variance has been removed or made explicit. Paths use forward slashes. Inputs are processed in sorted order. JSON is serialized with stable indentation and UTF-8 encoding and ends with a trailing newline for exact replay. Compression algorithms and formats are fixed. Timestamps are recorded in UTC with ISO-8601 precision. Optional fields appear only when explicitly provided by environment variables. Identical inputs yield identical outputs because no hidden sources of randomness are allowed to influence the stamp.

The receipt mirrors the verification surface so that an observer can confirm, without any private context, that the Merkle root, file set, and archives match the manifest. The receipt carries a reflective section in which the Merkle root is repeated and the included files and archives are echoed. That mirroring is not duplication for its own sake; it is a self-check that the artifact used for validation matches the artifact under validation, which reduces the chance of off-by-one mistakes in tooling.

The system is designed to evolve without breaking history. The manifest carries a version number so additional fields can be introduced without altering the meaning of existing ones. New anchors and archive formats can be added alongside the current set. New signature schemes can be introduced while maintaining acceptance of legacy attestations. Optional subsystems such as external anchoring and proof-of-work degrade gracefully when they are not present. The design performs τ-Crystal on its own surface: the document that describes the guarantees is carried by the same guarantees it describes.

This upgrade is not a flourish around the edges of documentation. It is a redefinition of documentation as an executable, evidence-bearing component of the system. The monographs are not simply readable; they are verifiable. They do not merely describe the pipeline; they travel through it. What remains after stamping is not a claim that something happened but a compact proof that it did, linked to the previous proof, bound to time, and reproducible on any machine that speaks the same simple language of files and hashes.
