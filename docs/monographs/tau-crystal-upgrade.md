# τ‑Crystal Infrastructure Upgrade — Cryptographic Documentation Attestation System

This upgrade converts documentation from narrative description into a computational artifact with verifiable provenance. The text itself now moves through the same deterministic pipeline as code: inputs are normalized, outputs are canonical, and every state carries an immutable fingerprint that binds it to time and to history. Trust is not inferred; it is computed.

The multi-signature subsystem separates proof materials from structural metadata. The manifest does not absorb raw signature bytes; it points to public keys and detached signature files with relative, POSIX-normalized paths so the same repository, checked out on different machines, remains comparable without translation. Verification constructs a stable message from the current Merkle root and its timestamp, attempts validation for each referenced signer, and reports both the number of attempted validations and the number that succeed. The distinction between an absent signature and an invalid signature is therefore explicit and diagnostically useful rather than hidden behind a single failure code.

The compression architecture emits a tarball and a zip archive, each recorded in the manifest with an explicit algorithm label and a SHA-256 digest. This dual-output system provides redundancy across platforms while remaining deterministic. Paths stored inside the archives are normalized to forward slashes, inputs are fed in lexicographic order, GNU tar format fixes structural layout, and ZIP_DEFLATED stabilizes compression behavior. The result is that a tarball or zip created on Windows is byte-identical to one created on Linux when the inputs are the same. Compression is treated as a declared transformation whose products are publicly auditable rather than as opaque containers.

External anchoring extends verification beyond repository control to an external, time-oriented witness. When the OpenTimestamps client is available, the stamper produces a timestamp for the manifest and writes the resulting .ots file alongside it. That file is an independent proof of existence at a specific instant in UTC and can be validated even if the repository is unavailable or its history is rewritten. If the anchoring tool is absent, stamping proceeds without anchors and the omission is explicit rather than silent. Anchors are referenced in the manifest with paths and digests so that they are checked like any other declared artifact.

Metadata is included deliberately and only when present. Author, description, tags, and source are accepted from environment variables, trimmed of incidental whitespace, normalized, and written into the manifest in a way that does not disturb canonical output when they are absent. Tags are parsed from a comma-separated string with defensive handling so stray spaces do not create accidental variants. Metadata therefore carries human intent without introducing entropy.

The verification script now proves more than file integrity. It recomputes the Merkle root from declared file hashes and compares it to the manifest’s value; it enforces algorithm labels on archives and checks their digests; it validates threshold signatures by counting attempts and successes against a declared requirement; it verifies the presence and hash of anchoring artifacts; and it optionally evaluates proof-of-work by checking leading zero bits of a hash constructed from the Merkle root, timestamp, and nonce. Each check yields precise diagnostics tied to a single invariant rather than a generic failure. Backward compatibility is maintained so earlier manifests remain valid under the expanded rules.

Continuity across time is asserted cryptographically. Each new manifest records the previous manifest’s Merkle root sourced from the prior commit, and verification ensures the link matches history. This creates a chain of documentation states in which no transition is implicit and no gap is allowed to pass unnoticed. The temporal structure of the record is thus as verifiable as its content.

The system now conducts multi-layer verification that begins with file hashes and extends through Merkle aggregation, detached signatures, and optional external timestamps. Attestation is no longer single-party; it is capable of threshold agreement across multiple signers. Packaging is no longer implicit; the exact format and digest of each archive are part of the public contract. Anchoring is no longer an afterthought; it binds the record to time outside the repository’s control. The result is a self-consistent loop in which the documentation that explains verification is itself verifiably produced.

Every pathway for incidental variance has been removed or made explicit. Paths use forward slashes. Inputs are processed in sorted order. JSON is serialized with stable indentation and UTF-8 encoding. Compression algorithms and formats are held constant. Timestamps are recorded in UTC with ISO-8601 precision. Optional fields are either provided by explicit environment variables or omitted entirely. Identical inputs yield identical outputs because no hidden sources of randomness are permitted to influence the stamp.

The manifest includes a version so the structure can evolve without invalidating history. New fields—additional anchors, signature schemes, or archive types—can be added without altering the meaning of existing entries, and the verifier treats such additions as extensions rather than as replacements. Optional subsystems such as external anchoring and proof-of-work degrade gracefully when they are not present. The design performs τ-Crystal on its own surface: the document that describes the guarantees is carried by the same guarantees it describes.

This system does not document τ-Crystal. It performs τ-Crystal. The monographs are no longer passive explanations. They are provable, inspectable, cryptographically anchored computational artifacts—executed, verified, and committed to time.
