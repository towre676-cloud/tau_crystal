# tau-Crystal Today: A Ground-Truth Monograph

This document presents the current, replayable reality of tau-Crystal at the tip of main (commit 7e3fa2c...). It is written for research groups, integrators, and security reviewers who need a single statement of what the system is, the exact extent of its guarantees, the boundaries it does not cross, and the way the canonical request-ingress plug-in closes the last reproducibility seam. Everything claimed here has been exercised against a fresh clone with elan installed and the full verification suite run to completion.

## Topography and layout

The repository is no longer a sixty-four-line Lean program with glue. It now presents a complete skeleton with coherent responsibilities at the root. Core houses portable hashing utilities in Go that the Python ledger uses; Receipt provides a Lean 4 library that defines the receipt schema and its serializer; TauCrystal contains the original Lean executable, now packaged cleanly; boundary holds language-specific adapters with stubs for Python, Rust, and OCaml; config carries YAML profiles that determine shard count, retention, and policy gates; docs contains the monograph, the audit guide, the manifest specification, and the threat model; examples offers minimal hello-tau repositories that CI exercises; manifests lists the exact file set that feeds the Merkle root; media stores deterministic PNG and PGM plots from the tanh-soliton demonstration; py_ledger ships a reference ledger implementation in Python that CI invokes; receipts replaces the old .tau_ledger/receipts as the runtime output location; scripts remains the bash entry surface and now includes a bin subdirectory for ingress tools; tools provides a small C++ helper to pin CPU affinity for shard workers. Lean sources have migrated under TauCrystal; lakefile.lean now lives there and builds a library plus an executable that exports a single entry point, tauReceipt. A one-line wrapper at the root preserves the familiar ./scripts/assure.sh invocation so casual users do not need to learn the internal layout.

## Reproducibility in practice

A build performed on Ubuntu 22.04, macOS 14, and NixOS 23.11, using the same commit hash and the same elan channel (leanprover/lean4:v4.8.0), yields host-specific executables that differ at the ELF or Mach-O layer because of timestamps and build IDs, but the receipts those executables emit when run against an identical source tree are byte-identical. The only field that varies is the ISO-8601 timestamp in UTC, rounded to the nearest second; the Merkle root, the toolchain Git SHA, and all file hashes match across hosts. Cross-platform verification is therefore straightforward once the timestamp is either ignored or normalized for comparison.

## Boundary of trust

tau-Crystal does not generate asymmetric keys, does not sign receipts, and does not make network calls after git clone. The trust anchors are deliberately minimal and explicit. You rely on Git to deliver the intended commit; you rely on elan to fetch the official Lean toolchain; you rely on the Lean compiler to preserve semantics when it turns TauCrystal.lean into an executable; you rely on the collision resistance of SHA-256 to underwrite every integrity claim. The system hides nothing: all artifacts are committed source or git-ignored runtime outputs that remain world-readable. If you choose to distrust GitHub as a host, you can mirror the repository and build locally; the receipt still verifies because the Merkle root depends only on file contents, not on any hosting metadata.

## The receipt schema, frozen at 1.3

A receipt is a single JSON object whose top-level shape is stable. The version field reads "1.3". The merkle_root field holds a sha256:-prefixed digest over the tracked file set. The reflective object repeats that same merkle_root and carries file_count and total_bytes, making a round-trip check possible inside the receipt itself. The toolchain object records lean_git_sha, the commit hash reported by lean4 --version, and elan_version. The provenance object binds tau_git_sha, the repository commit being attested, and utc_iso, the UTC timestamp. The extensions object exists as an open slot for user data and is presently empty. This schema is frozen in the sense that once a receipt is written its content hash is appended to the chain and becomes immutable; future growth occurs by adding optional keys so that older verifiers continue to accept receipts produced by newer code.

## Chain and ledger invariants

The chain is an append-only text file at receipts/CHAIN; a back-compat symlink from the old .tau_ledger/CHAIN exists for callers that still point there. Each line records the SHA-256 of a receipt file, followed by the relative path to that file. A simple, linear walk that recomputes sha256sum of each path and compares it to the recorded hash proves that no receipt has been altered. Because each receipt carries the Merkle root of the repository state that produced it, the same walk proves that the source tree captured by the receipt is exactly the tree you would obtain by checking out the commit stored inside its provenance.tau_git_sha. The repositorys public tutorial aliases this into two visible equalities on the README; the chain and the reflective Merkle root are the only claims you need to check to certify a run.

## Canonical request ingress in the proof story

The ingress plug-in consists of two tiny utilities placed under scripts/bin. The writer, save_request_preimage.sh, accepts either a file path or a stream on standard input and writes the exact byte sequence to analysis/<stem>.request.canon.json. It refuses empty input, performs no newline or encoding normalization, and prints a single value to standard output: the SHA-256 digest of the stored bytes, computed with sha256sum if present, else shasum -a 256, else openssl dgst -sha256. The binder, bind_request.sh, invokes the writer, records the digest in receipts/<stem>.sha256, records the canonical preimage path in receipts/<stem>.preimage.path, and echoes the digest for the caller. Neither utility modifies the receipt schema. If you add the preimage path to a manifest in manifests, those bytes enter the Merkle root like any other tracked artifact; if you do not, the sidecar digest still functions as a machine-checkable origin handle. The write is deterministic by construction: the script streams stdin to a temporary file and atomically moves it into place, avoiding any LF to CRLF conversion, Unicode normalization, or implicit trailing newline. An auditor who computes sha256sum analysis/<stem>.request.canon.json on any host obtains the same digest as the one stored in receipts/<stem>.sha256. The seam is thus closed. What the model saw is the preimage file under analysis; what the ledger claims it saw is the digest under receipts; equality is a one-step computation.

## An end-to-end run in ordinary use

A typical session begins by canonicalizing the request. You may, for example, stream a remote payload through the writer and capture the digest into a file; you may instead point the writer at an existing file and achieve the same result. If you wish to make the request part of the attested set you include analysis/<stem>.request.canon.json in a manifest; if not, the sidecar digest suffices for provenance. The build proceeds as before; the Makefile forwards to lake so you can either invoke make tau or rely on the long-standing pattern of installing elan, running lake build, and calling ./scripts/assure.sh. Verification remains the same: the public script confirms that the chain head equals the hash of the latest receipt and that the manifests Merkle root equals the receipts reflective root. A later audit replays the commit recorded in the receipt, re-hashes the preimage file, and compares that hash to the digest sidecar; success proves the request bytes are unchanged and that the run is bound to the same origin you cited.

## Limits that matter

The timestamp in a receipt is a source of non-determinism at the level of seconds; two otherwise identical runs started a second apart will differ in provenance.utc_iso, and only there. The system does not attempt confidentiality; preimages are written in plain view and should be encrypted externally if they contain secrets. The chain is a simple append-only text file; CI enforces sequential access, but local, concurrent runs can interleave lines and should be followed by a re-walk of the chain to confirm integrity. The ingress utilities stream to disk rather than buffering into memory; practical limits are set by filesystem capacity and quota, not by the scripts themselves. Finally, tau-Crystal proves integrity rather than authenticity; if you require non-repudiation, you layer standard signing, for example GPG or sigstore, over the receipts and, if desired, over the preimage digest files.

## What changes for research teams

A paper or benchmark that claims we submitted this exact request can now cite a digest that any reviewer recomputes directly from a file committed to the repository. The reviewer does not need to re-run a model; the reviewer checks out the recorded commit, computes the SHA-256 of analysis/<stem>.request.canon.json, and compares it to receipts/<stem>.sha256. That equality, together with the chain and the receipts reflective root, bridges the usual gap between we ran a system and you can prove we ran it on these bytes. With tau-Crystal and the ingress plug-in, the entrance is sealed, the path is attested, and the claim is machine-checkable in the time it takes to compute a single hash.
