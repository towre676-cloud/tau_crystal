In the consolidation phase of the τ‑Crystal project, a full audit-binding system has been installed to meet the declared guarantees of manifest integrity, receipt chaining, verifiable runtime signatures, and CI-attested releases. This sweep introduces scripts/assure.sh as a first-class, bash‑only assurance generator that deterministically hashes tracked files, constructs a Merkle root, links to prior receipts via SHA-256 chaining, and emits a tamper-evident runtime snapshot under receipts/.

Each invocation of assure.sh transforms the state of the repository into an immutable circular signature—cryptographically encoding every tracked input, execution timestamp, and contextual hash. The output begins with a HEAD: line that binds the run to its predecessor, forming a cryptographic chain. If no prior receipt exists, a GENESIS hash is injected to seed the run. This ensures that every output is not just a hash but a directed arc in a signed computational trajectory—enabling transparent diffs, retroactive validation, and deterministic rebasing of execution history.

The Makefile has been augmented with a make assure target, normalizing this operation into a single keystroke regardless of environment. Simultaneously, .git/hooks/pre-push has been wired to invoke the assurance script on every outbound commit, printing the HEAD: line inline so developers are continuously aware of the state transition being chained. This hook is non-blocking by default, but it respects an optional STRICT=1 flag, which hard-fails pushes if the subsequent attestation (via receipt2attestation.py) does not validate the manifest chain or Merkle root. This design respects the principle of reversible rigor: developers can engage lightweight audit awareness by default and harden to enforcement by flipping a single environmental toggle.

The continuous integration pipeline has been extended with .github/workflows/assure.yml, which ensures that all push and pull request events execute the assurance script in a clean environment. The HEAD hash is recomputed, compared, optionally attested, and uploaded under a named artifact. This fulfills the full-circle audit guarantee: reviewers can download any receipt artifact from a CI run and compare its HEAD line or Merkle root against the golden baseline or a prior artifact. No secrets, no containers, no guessing—just observable hash transitions.

To close the chain at the release level, .github/workflows/release-staple.yml has been added to compute a receipt at tag publication time and staple it directly to the GitHub release. This operationalizes the concept of an "attested output": when a release is published, it carries with it a cryptographic receipt describing the state of the codebase, linked to its parent chain, signed with SHA-256, and grounded in a verifiable runtime snapshot. Reviewers, auditors, collaborators, and funding agencies can now download a receipt file directly from the release page and verify its HEAD against public lineage. The result is a cryptographic signature trail that moves from ephemeral execution to persistent verification without any exotic toolchains or external infrastructure.

This entire scaffold remains bash-only. The receipt emitter uses git ls-files, sha256sum, and sort | xargs under a CRLF-neutral pipeline, ensuring identical operation in Git Bash (Windows), Ubuntu (CI), macOS, and WSL. It explicitly strips history expansion (set +H), does not use heredocs, and guards against empty tails and dangling lines. The cryptographic root is built via iterative pairing of sorted hashes into a Merkle-style structure, and chained receipts are deterministic even when tracked files are reordered or resaved.

The audit trail now satisfies the full ε‑arc / Υ‑precision metaphor: every execution transition becomes a measurable arc in τ-space, bounded by a Merkle-anchored circle and traced back to a cryptographic parent. Entry deviations are ε-detectable (even one-byte perturbations change the HEAD), and Υ-resolution is pinned to SHA-256’s granularity. The release state is no longer just a commit SHA; it is a certified intersection between content and chain state. The receipts/latest.txt file always contains the current manifest, and every prior receipt is available under receipts/receipt-*.txt as a historical ledger.

The .gitignore has been extended to exclude .tau_ledger/ and receipts/latest.txt, ensuring that ephemeral logs and dynamic links do not pollute version control. Persistent receipts remain indexed for long-term reproducibility. Because the entire stack operates without dependencies, no Lean 4 tools, Dockerfiles, or Python environments are required to perform a complete audit. Nevertheless, optional receipt2attestation.py logic gates exist for hard-fail conditions, and the Lean 4 upgrade path remains open for symbolic theorem-backed chains.

This sweep transforms τ‑Crystal from an experimental ledger into a functional runtime certificate system, where each computation emits a claim and a proof, and every published version carries its own audit trail. Reviewers no longer need to trust that a release represents what was run; they can check, diff, and trace every link in the chain.
